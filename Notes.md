# Записки о программировании дисплеев микроконтроллеров для хобби-проектов
## Мотивация
В поисках подходящих для моего проекта графических библиотек, я посмотрел на AdafruitGFX, TFT_eSPI и LVGL.
Основных требований было три: поддержка unicode-шрифтов, виртуальных экранов и возможности использования более одного дисплея с одним и тем же драйвером.
Последнее требование было от того, что я предполагал в проекте разбить изображение на несколько одиановых экранов. К моему удивлению, ни одна из
библиотек мне не подошла. Поскольку речь о хобби и ни о каком рациональном использовании времени на разработку речи не идёт, то я могу тратить столько времени и сил,
сколько считаю нужным, а значит, могу смело отметать упрёки о "строительстве велосипеда" и "NIH-синдроме" и смело писать свою библиотеку. 
Просто потому, что я хочу, могу и она мне нужна. В голове ещё со студенчества остались знания основ графических алгоритмов, когда-то я уже делал свою реализацию
для DOS, так что, повторю для микроконтроллера. Изучив исходные коды других библиотек, я нашёл несколько мест, которые можно сделать оптимальнее по
производительности, оптимальнее по програмному интерфейсу и вообще добавить то, чего там нет. Больше всего мне понравились исходные тексты LVGL, там видно,
что автор на голову лучше разбирается в индустрии программирования, чем авторы Adafruit и TFT_eSPI.

## Микроконтроллер
В своём проекте я ориентировался на ESP32. Мне необходимо было иметь WiFi и Bluetooth, а так же достаточно RAM для виртуальных экранов. Недавно (Juli 2022) появился
Raspberry Pi Pico W, в котором к основному чипу RP2040 (стоимость $1) добавили чип CYW43439 WiFi (стоимость около $2), который так же умеет Wifi и Bluetooth,
но возможность Bluetooth пока что заблокирована програмно. Информация к размышлению: чип CYW43439 WiFi имеет два ядра Cortex-M3, работающих независимо. Одно ядро
для WLAN имеет 512KB RAM + 640 KB ROM, другое ядро для Bluetooth имеет 160 KB RAM + 576 KB ROM. Сравните это с основным RP2040, который имеет 2 ядра Cortex-M0 
с общей памятью 264 KB RAM. В общем, в будущем я не отвергаю использование альтернативных микроконтроллеров, но, на текущий момент, мне ESP32 представляется
оптимальным выбором. ESP32 имеет 520 KB RAM + большинство плат имеет 4MB Flash, 2 довольно быстрых ядра с реализацией плавающей арифметики. 
Обычно, после загрузки FreeRTOS, модулей WiFi, TLS и других частей, пользовательскому приложению остаётся около 320KB RAM, на что можно смело 
расчитывать в своих проектах.

## Дисплеи
Заинтересовавшись темой, я приобрёл несколько разных дисплеев, что были доступны локально. Выяснилось, что не так уж большое разнообразие предложения.
Один и тот же контроллер может использоваться с дисплеями разных размеров, на разных вариантах шины. Сначала я не понял систему и пошёл по пути авторов
Adafruit и TFT_eSPI, но потом переосмыслил и здесь представлю своё видение. На настоящий момент я использовал следующие комбинации контроллеров и шин:

 * SSD1306 / SPI, I2C
 * ILI9341 / SPI, Parallel 8 bit
 * ST7735 / SPI
 * ST7789 / SPI

Это, на данный момент, основные варианты дисплеев, что можно купить недорого для хобби-проектов. SSD1306 - монохромные дисплеи, иногда некоторые линии 
сделаны не белым цветом, остальные дисплеи цветные. У цветных дисплеев возможна глубина цвета 4, 12, 16, 18 и 24 бита. Мне не удалось нигде обнаружить 8-ми битные
дисплеи, хотя, с точки зрения оптимизации расхода RAM и удобства работы, они были бы самыми оптимальными. О существовании 4-битного дисплея я читал, но сам
такой не покупал. Работа с 12-битным цветом удовольствия даёт мало, постоянно приходится понимать в чётной или нечётной точке ты находишься, что особенно
"весело", когда приходится один виртуальный дисплей рисовать на другом. Работа с 18-битным цветом сводится к работе с 24-битным, 
что даёт заметный расход RAM и заметно роняет скорость работы с дисплеем. Цветопередача всех дисплеев просто ужасна, в итоге, 
я не увидел никакого смысла в 18 и в 24 битах. Примерно к такому же выводу пришли авторы Adafruit и TFT_eSPI, там реализован только 16-битный цвет. 
16-битный цвет оптимален как по представлению цветной картинки, так и по удобству работы с RAM, с ним проще всего делать расчёты, пересылки SPI/DMA/RAM.

В своей внутренней памяти дисплей хранит цвет в максимальной разрядности, настройки 12, 16, 18 и 24 бита - это настройки разрядности интерфейса, дисплей 
трансформирует принимаемые и передаваемые данные во внутрннюю разрядность. Почти все контроллеры поддерживают чтение из внутренней памяти, но эта возможность
не всегда реализована интерфейсом физически, а если реализована, то скорость чтения там такая же, как записи, часто недостаточная. 
Если требуется получать цвет точки на дисплее, то, по моему мнению, лучше это делать из внутренней RAM, держа там виртуальное изображение. Кроме того,
монохромный SSD1306 умеет отображать только блоками по 8 точек, а, значит, надо знать что там с другими точками, если мы не весь блок меняем.

## Шина
Скорость передачи данных - самое сложное место в производительности. Современный микроконтроллер может быть очень быстрым, но если шина данных медленна, то
это ему может оказаться бутылочным горлышком графической производительности. Мной были испробованы следующие шины: SPI, I2C, 8-bits Parallel Bus. 

* Самая медленная I2C, данные передаются побитно с максимальной скоростью редко выше 1 мегагерца. У SSD1306 максимальная скорость I2C интерфейса 200 килогерц.
* Параллельная шина может давать скорость близкую к SPI, но при этом максимально расходует процессор, существование отдельных контроллеров для такой
шины мне неизвестно. К недостаткам параллельной шины можно отнести большое количество требуемых выходов GPIO. Это так же накладывает определённые ограничения
на интерфейсы программирования, нельзя уже пользоваться обычными функциями установки уровней GPIO по одному, надо ставить их маской все сразу, что не
всегда удобно предоставляется фреймворками и требует прямого доступа к оборудованию. 
* SPI на ESP32 имеет максимальную скорость передачи 80 мегагерц, при этом сама передача может осуществляться внешним контроллером DMA, освобождая процессор. Не все дисплеи поддерживают такую высокую скорость, но, часто, можно получить скорость выше, чем заявлена в документации. Например, на одном из дисплеев завялена максимальная скорость 27 мегагерц, но он нормально работает на 40 мегагерц, даже соединённый обычными проводами воткнутыми через breadboard, какие-то заметные артефакты начинаются только после 60 мегагерц. 

### Особенности передачи данных
Нельзя вот так просто взять и передать данные в контроллер дисплея по SPI/Parallel шине. Для контроллеров дисплеев поток битов надо делить на команды и данные 
к этим командам, для этого выделяется отдельный выход GPIO, который и сигнализирует природу передающихся данных, и это надо синхронизировать с самой передачей.
Для SPI шины с DMA контроллером приходится добавлять дополнительный обработчик, который и будет управлять этим выходом. Что дополнительно замедляет передачу,
особенно, когда команд много, а данных мало.
