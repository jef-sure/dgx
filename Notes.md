# Записки о программировании дисплеев микроконтроллеров для хобби-проектов
## Мотивация
В поисках подходящих для моего проекта графических библиотек, я посмотрел на AdafruitGFX, TFT_eSPI и LVGL.
Основных требований было три: поддержка unicode-шрифтов, виртуальных экранов и возможности использования более одного дисплея с одним и тем же драйвером.
Последнее требование было от того, что я предполагал в проекте разбить изображение на несколько одиановых экранов. К моему удивлению, ни одна из
библиотек мне не подошла. Поскольку речь о хобби и ни о каком рациональном использовании времени на разработку речи не идёт, то я могу тратить столько времени и сил,
сколько считаю нужным, а значит, могу смело отметать упрёки о "строительстве велосипеда" и "NIH-синдроме" и смело писать свою библиотеку. 
Просто потому, что я хочу, могу и она мне нужна. В голове ещё со студенчества остались знания основ графических алгоритмов, когда-то я уже делал свою реализацию
для DOS, так что, повторю для микроконтроллера. Изучив исходные коды других библиотек, я нашёл несколько мест, которые можно сделать оптимальнее по
производительности, оптимальнее по програмному интерфейсу и вообще добавить то, чего там нет. Больше всего мне понравились исходные тексты LVGL, там видно,
что автор на голову лучше разбирается в индустрии программирования, чем авторы Adafruit и TFT_eSPI.

## Микроконтроллер
В своём проекте я ориентировался на ESP32. Мне необходимо было иметь WiFi и Bluetooth, а так же достаточно RAM для виртуальных экранов. Недавно (Juli 2022) появился
Raspberry Pi Pico W, в котором к основному чипу RP2040 (стоимость $1) добавили чип CYW43439 WiFi (стоимость около $2), который так же умеет Wifi и Bluetooth,
но возможность Bluetooth пока что заблокирована програмно. Информация к размышлению: чип CYW43439 WiFi имеет два ядра Cortex-M3, работающих независимо. Одно ядро
для WLAN имеет 512KB RAM + 640 KB ROM, другое ядро для Bluetooth имеет 160 KB RAM + 576 KB ROM. Сравните это с основным RP2040, который имеет 2 ядра Cortex-M0 
с общей памятью 264 KB RAM. В общем, в будущем я не отвергаю использование альтернативных микроконтроллеров, но, на текущий момент, мне ESP32 представляется
оптимальным выбором. ESP32 имеет 520 KB RAM + большинство плат имеет 4MB Flash, 2 довольно быстрых ядра с реализацией плавающей арифметики. 
Обычно, после загрузки FreeRTOS, модулей WiFi, TLS и других частей, пользовательскому приложению остаётся около 320KB RAM, на что можно смело 
расчитывать в своих проектах.

## Дисплеи
Заинтересовавшись темой, я приобрёл несколько разных дисплеев, что были доступны локально. Выяснилось, что не так уж большое разнообразие предложения.
Один и тот же контроллер может использоваться с дисплеями разных размеров, на разных вариантах шины. Сначала я не понял систему и пошёл по пути авторов
Adafruit и TFT_eSPI, но потом переосмыслил и здесь представлю своё видение. На настоящий момент я использовал следующие комбинации контроллеров и шин:

 * SSD1306 / SPI, I2C
 * ILI9341 / SPI, Parallel 8 bit
 * ST7735 / SPI
 * ST7789 / SPI

Это, на данный момент, основные варианты дисплеев, что можно купить недорого для хобби-проектов. SSD1306 - монохромные дисплеи, иногда некоторые линии 
сделаны не белым цветом, остальные дисплеи цветные. У цветных дисплеев возможна глубина цвета 4, 12, 16, 18 и 24 бита. Мне не удалось нигде обнаружить 8-ми битные
дисплеи, хотя, с точки зрения оптимизации расхода RAM и удобства работы, они были бы самыми оптимальными. О существовании 4-битного дисплея я читал, но сам
такой не покупал. Работа с 12-битным цветом удовольствия даёт мало, постоянно приходится понимать в чётной или нечётной точке ты находишься, что особенно
"весело", когда приходится один виртуальный дисплей рисовать на другом. Работа с 18-битным цветом сводится к работе с 24-битным, 
что даёт заметный расход RAM и заметно роняет скорость работы с дисплеем. Цветопередача всех дисплеев просто ужасна, в итоге, 
я не увидел никакого смысла в 18 и в 24 битах. Примерно к такому же выводу пришли авторы Adafruit и TFT_eSPI, там реализован только 16-битный цвет. 
16-битный цвет оптимален как по представлению цветной картинки, так и по удобству работы с RAM, с ним проще всего делать расчёты, пересылки SPI/DMA/RAM.

В своей внутренней памяти дисплей хранит цвет в максимальной разрядности, настройки 12, 16, 18 и 24 бита - это настройки разрядности интерфейса, дисплей 
трансформирует принимаемые и передаваемые данные во внутрннюю разрядность. Почти все контроллеры поддерживают чтение из внутренней памяти, но эта возможность
не всегда реализована интерфейсом физически, а если реализована, то скорость чтения там такая же, как записи, часто недостаточная. 
Если требуется получать цвет точки на дисплее, то, по моему мнению, лучше это делать из внутренней RAM, держа там виртуальное изображение. Кроме того,
монохромный SSD1306 умеет отображать только блоками по 8 точек, а, значит, надо знать что там с другими точками, если мы не весь блок меняем.

## Шина
Скорость передачи данных - самое сложное место в производительности. Современный микроконтроллер может быть очень быстрым, но если шина данных медленна, то
это ему может оказаться бутылочным горлышком графической производительности. Мной были испробованы следующие шины: SPI, I2C, 8-bits Parallel Bus. 

* Самая медленная I2C, данные передаются побитно с максимальной скоростью редко выше 1 мегагерца. У SSD1306 максимальная скорость I2C интерфейса 200 килогерц.
* Параллельная шина может давать скорость близкую к SPI, но при этом максимально расходует процессор, существование отдельных контроллеров для такой
шины мне неизвестно. К недостаткам параллельной шины можно отнести большое количество требуемых выходов GPIO. Это так же накладывает определённые ограничения
на интерфейсы программирования, нельзя уже пользоваться обычными функциями установки уровней GPIO по одному, надо ставить их маской все сразу, что не
всегда удобно предоставляется фреймворками и требует прямого доступа к оборудованию. 
* SPI на ESP32 имеет максимальную скорость передачи 80 мегагерц, при этом сама передача может осуществляться внешним контроллером DMA, освобождая процессор. Не все дисплеи поддерживают такую высокую скорость, но, часто, можно получить скорость выше, чем заявлена в документации. Например, на одном из дисплеев завялена максимальная скорость 27 мегагерц, но он нормально работает на 40 мегагерц, даже соединённый обычными проводами воткнутыми через breadboard, какие-то заметные артефакты начинаются только после 60 мегагерц. 

### Особенности передачи данных
Нельзя вот так просто взять и передать данные в контроллер дисплея по SPI/Parallel шине. Для контроллеров дисплеев поток битов надо делить на команды и данные 
к этим командам, для этого выделяется отдельный выход GPIO, который и сигнализирует природу передающихся данных, и это надо синхронизировать с самой передачей.
Для SPI шины с DMA контроллером приходится добавлять дополнительный обработчик, который и будет управлять этим выходом. Что дополнительно замедляет передачу,
особенно, когда команд много, а данных мало.

## Команды дисплея
Инициализация дисплея включает в себя некоторый стандартный протокол, обычно довольно подробно указанный в документации -- какие команды в какой последовательности
с какими задержками надо подать первыми, чтобы дисплей перешёл в некоторое стандартное состояние приёма команд на исполнение. После инициализации основными
командами дисплея становятся установка рабочей области и передача или чтение данных из этой области. Рисование точки - заливка области размером 1х1 пиксель;
рисование прямой линии -- заливка прямоугольника у которого одна сторона имеет размер 1 пиксель; рисование произвольной линии -- комбинация из
рисований точек и прямых линий и так далее. Таким образом, типичное рисование одной точки -- 3 команды дисплею, к каждой дополнительно блок данных.

### Особенности реализации протоколов дисплея
Очень хочется красиво разделить уровни друг от друга. К сожалению, излишний абстракционизм может заметно повредить оптимизациям. Приходится искать некоторый
компромисс, чтобы и шина была абстрактна и протоколы независимы. Например, многие SPI дисплеи имеют разделный команды для установки горизонтальных и 
вертикальных границ области для последующего обновления или чтения, каждая команда при этом состоит из двух частей - команды и данных. Но SSD1306 
не такой, у него границы области устанавливаются как команды, а данные идут как их часть, что требует несколько иной структуры организации данных. При этом
хочется избежать избыточных выделений DMA-пригодной памяти. 

### Оптимизация графичеких примитивов
Оптимизация рисования графических примитивов включает в себя адаптацию графических алгоритмов, чтобы как можно больше использовать сплошные заливки областей
и как можно меньше индивидуальные точки, плюс для SPI дисплеев можно заметно сэкономить пересылаемые команды при определённой очерёдности рисования примитивов,
чтобы менялась, например, только вертикальная или только горизонтальная координата. Например, если классический алгоритм Брезенхема рисования линии оптимизировать на
рисования горизонтальных/вертикальных линий вместо отдельных точек, то его скорость в среднем вырастает на 50%. Примерно так же с рисованием окружности - если
отказаться от Брезенхема и вычислять не 1/8, а целую четверть, то благодаря очерёдности расстановки точек и оптимизациям линий можно сэкономить те же 50%.
Один из графических примитивов -- строка или столбец заполненная/ый произвольным цифровым шаблоном. Рисование окружности с таким шаблоном требует алгоритма,
отличного от Брезенхема.

## Виртуальные экраны
Поскольку ESP32 имеет довольно много RAM, можно организовать виртуальные экраны, на которых осуществлять различные операции рисования, а затем выводить целиком.
Например, необходимо постоянно показывать значения датчика, для этого на экране перед выводом значений надо очистить область. Если делать это довольно часто,
то будет весьма заметное "моргание" из-за того, что человек будет видеть иногда уже очищенную область, но ещё не заполненную. С помощью виртуального экрана
можно целиком сформировать нужное изображение, а затем целиком вывести его на экран. По моему опыту, никаких эффекторв/артефактов на экране при этом не будет.
В качестве примера я делал анимированное перетекание одних цифр в другие для электронных часов. 

### Цветовая разрядность виртуальных экранов
Цифровая разрядность виртуального экрана не обязана совпадать с физическим. Можно, например, сделать монохромный виртуальный экран и выводить его любыми двумя
цветами из палитры физического экрана. Можно сделать 8-битный виртуальный экран, который выводить на экран согласно некотрой палитре. Например, я делал рисование
фигур в 8-битном экране, затем операцию смягчения границ изображения, а затем уже вывод на физический экран согласно палитре, где 8-битное значение было согласовано
с яркостью в палитре физического экрана. Проще всего пользоваться 16-битным цветом для физического и виртального экранов, но расход оперативной памяти
может стать весьма заметным. Экран 320х240 в 8-битном цвете занимает 76800 байт, а в 16-битном цвете 153600, что очень быстро скушает доступную 
память микроконтроллера. Конечно, не обязательно виртуальные экраны делать равными по размерам физическому, лучше даже вообще их такими не делать, это заметно
сэкономит время, необходимое для их физического отображения. 

Возможно использовать виртуальные экраны разной разрядности одновременно, например, чтобы в итоге подготовить некоторый готовый 16-разрядный кусочек для быстрого
вывода. По моим расчётам, если предполагается делать обновление для целого экрана 320х240 16-битным цветом, потребуется выводить 153600 байт каждые 1/30 секунды,
что потребует пропускной способности 4.6 МБ/сек, что близко к практическому лимиту реальных дисплеев на SPI шине. 

Если предполагается физическая пересылка данных из виртуального экрана в физический, то выделенная для него память должна быть доступна для DMA-контроллера, что
накладывает дополнительные ограничения на ресурсы микроконтроллера.

### Виртуальные монохромные экраны
Помимо очевидного виртуального использования, монохромные экраны можно применять как хранилище картинки для монохромных дисплеев. Тот же SSD1306 при использовании
I2C шины не умеет операцию чтения памяти экрана, поэтому рисовать на таком экране и не затирать блоки по 8 вертикальных точек можно только если все операции 
проводить сначала на его виртуальной копии, а результат пересылать на физический экран.

Второй вариант использования монохромных экранов -- матричные шрифты. Каждый символ как отдельный маленький виртуальный экран, где "0" означает прозрачный цвет.

## Шрифты
Известные мне графические библиотеки для микроконтроллеров не поддерживают использование произвольных Юникодных диапазонов. Это первое, с чем я столкнулся,
как русскоязычный разработчик, живущий в Германии. То есть, мне часто необходима одновременная поддержка Русского языка, а так же европейских с их умляутами, 
акцентами и так далее. И в качестве решения мне предлагается пользоваться какой-либо однобайтовой кодировкой, чтобы было удобно индексировать глифы (изображения)
символов, экономя память микроконтроллера. Значит, первое, что мне надо -- поддержка произвольных диапазонов шрифтов. Второе -- вывод надписей в произвольной
ориентации. Хорошо, когда контроллер дисплея поддерживает различные способы чтения из памяти дисплея, эффективно предлагая при этом повороты и перевороты 
изображения, а если нет? Если нет, то надо уметь это делать самостоятельно, но не все примитивы можно просто так развернуть по координатам, некоторые, как шрифты,
должны это уметь делать самостоятельно.

### Источники шрифтов
Для матричных проще всего взять конвертор из TTF, но далеко не все могут нормально красиво сконвертироваться. Шрифт Terminus, во всех чётных 
размерах очень хорошо конвертируется, прямо идеально. 

### Векторные шрифты
Пара слов о векторных шрифтах. Для анимированных цифр в одном проекте я сделал, что любая цифра представлена 3-мя кривыми Безье 3-го порядка. 
В последствии, я написал свой редактор для таких шрифтов, добавив возможность рисования кривых Безье второго порядка, линий и точек. Если не стремиться
к особой красоте, то 3 кривые хватает почти для любого символа. Координаты записываются числами 0-255, итого 2 байта на одну точку. 4 точки в одной кривой.
3 кривых на символ. 24 байта на один векторный символ. С учётом произвольного масштабирования по любой оси без потери качества, это довольно неплохой результат.
Для сравнения, 24 байта занимает описание матричного символа размером 12х16. Трудоёмкость рисования векторных символов, конечно, более высокая, чем матричных.
